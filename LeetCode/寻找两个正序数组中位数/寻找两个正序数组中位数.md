# 📚 LeetCode 学习笔记：寻找两个正序数组的中位数

## 🧩 题目描述

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`，请你找出并返回这两个正序数组的中位数。

---

### ✅ 示例

#### 示例 1：

输入: 
```java
nums1 = [1, 3], nums2 = [2]
输出:


2.00000
解释：合并数组 = [1,2,3] ，中位数 2。

示例 2：
输入:


nums1 = [1, 2], nums2 = [3, 4]
输出:


2.50000
解释：合并数组 = [1, 2, 3, 4] ，中位数 (2 + 3) / 2 = 2.5。

🎯 题目要求
nums1.length == m

nums2.length == n

0 <= m <= 1000

0 <= n <= 1000

1 <= m + n <= 2000

-10^6 <= nums1[i], nums2[i] <= 10^6
```
```
💡 解题思路：二分法（Binary Search）
我们可以通过使用 二分查找 来在两个排序数组中找到中位数。核心思路是将较小的数组进行二分查找，确保分割点的正确性，使得左右两边的数的个数相等或左右两边的差为 1。利用这一点，最终就能找到中位数。

🧠 核心思想：
确保较小的数组做二分查找：我们始终选择较短的数组进行二分查找，可以减少计算量。

二分查找分割点：将两个数组分割成左右两部分，确保左边的最大值小于右边的最小值。

计算中位数：

如果总长度为奇数，返回左半部分的最大值；

如果总长度为偶数，返回左半部分的最大值和右半部分的最小值的平均值。
```
🧪 Java 实现代码
```java
class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {
        // 确保 A 是较小的数组
        if (A.length > B.length)
            return findMedianSortedArrays(B, A);
        
        int m = A.length, n = B.length;
        int left = 0, right = m;
        int leftSize = (m + n + 1) / 2;
        
        while (left <= right) {
            int i = (left + right) / 2;  // A 的分割点
            int j = leftSize - i;        // B 的分割点
            int Aleft = i == 0 ? Integer.MIN_VALUE : A[i - 1];
            int Aright = i == m ? Integer.MAX_VALUE : A[i];
            int Bleft = j == 0 ? Integer.MIN_VALUE : B[j - 1];
            int Bright = j == n ? Integer.MAX_VALUE : B[j];
            
            // 判断分割是否满足条件
            if (Aleft <= Bright && Bleft <= Aright) {
                if ((m + n) % 2 == 0) {
                    // 偶数长度，取左右两边的最大最小值
                    return (Math.max((double) Aleft, (double) Bleft) + Math.min((double) Aright, (double) Bright)) / 2;
                } else {
                    // 奇数长度，取左边的最大值
                    return Math.max((double) Aleft, (double) Bleft);
                }
            } else if (Aleft > Bright) {
                right = i - 1;  // 左边 A 的分割点太大，调整
            } else {
                left = i + 1;   // 左边 B 的分割点太大，调整
            }
        }
        
        throw new IllegalArgumentException("Input arrays are not sorted.");
    }
}
🧮 时间复杂度分析
时间复杂度：O(log(min(m, n)))，其中 m 和 n 分别是两个数组的长度。我们通过在较小的数组上进行二分查找来缩小查找范围，时间复杂度为对数级别。

空间复杂度：O(1)，我们只使用了常数空间。

📌 总结
本题的关键在于利用 二分查找 找到正确的分割点，确保左右两部分的元素个数符合条件。

通过合并两个排序数组的思路，我们可以高效地找到中位数。

边界条件的处理需要特别小心，避免越界和分割不当的情况。